Metadata-Version: 2.4
Name: sproclib
Version: 1.0.0
Summary: SPROCLIB - Standard Process Control Library for chemical processes
Home-page: https://github.com/gressling/sproclib
Author: Thorsten Gressling
Author-email: gressling@paramus.ai
Project-URL: Documentation, https://sproclib.readthedocs.io/
Project-URL: Source, https://github.com/gressling/sproclib
Project-URL: Tracker, https://github.com/gressling/sproclib/issues
Keywords: process control,chemical engineering,PID,control systems,process modeling,simulation
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Manufacturing
Classifier: Topic :: Scientific/Engineering :: Chemistry
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy>=1.20.0
Requires-Dist: scipy>=1.7.0
Requires-Dist: matplotlib>=3.4.0
Requires-Dist: control>=0.9.0
Provides-Extra: dev
Requires-Dist: pytest>=6.0; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: sphinx>=4.0; extra == "dev"
Requires-Dist: sphinx-rtd-theme; extra == "dev"
Requires-Dist: black; extra == "dev"
Requires-Dist: flake8; extra == "dev"
Provides-Extra: docs
Requires-Dist: sphinx>=4.0; extra == "docs"
Requires-Dist: sphinx-rtd-theme; extra == "docs"
Requires-Dist: myst-parser; extra == "docs"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: keywords
Dynamic: license-file
Dynamic: project-url
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

# SPROCLIB - The TensorFlow/Keras for Chemical Engineering üß™‚öóÔ∏è

**A revolutionary Python library that brings machine learning design patterns to chemical process control**

[![Python Version](https://img.shields.io/badge/Python-3.8%2B-blue)](https://python.org)
[![License](https://img.shields.io/badge/License-MIT-green)](LICENSE)
[![API Style](https://img.shields.io/badge/Style-TensorFlow%2FKeras-orange)](https://tensorflow.org)
[![Documentation](https://img.shields.io/badge/Docs-Sphinx-blue)](docs/)

## üöÄ **Build Chemical Plants Like Neural Networks**

```python
from unit.plant import ChemicalPlant
from unit.reactor.cstr import CSTR
from unit.pump import CentrifugalPump
from transport.continuous.liquid import PipeFlow

# Define plant (like keras.Sequential)
plant = ChemicalPlant("My Chemical Plant")

# Add units sequentially (like model.add(layers))
plant.add(CentrifugalPump(H0=50.0, eta=0.75), name="feed_pump")
plant.add(PipeFlow(length=200.0, diameter=0.15), name="pipeline")
plant.add(CSTR(V=150.0, k0=7.2e10), name="reactor")

# Connect units (functional API)
plant.connect("feed_pump", "pipeline", "feed_stream")
plant.connect("pipeline", "reactor", "reactor_feed")

# Compile for optimization (like model.compile)
plant.compile(
    optimizer="economic",
    loss="total_cost",
    metrics=["profit", "conversion", "efficiency"]
)

# Optimize plant operations (like model.fit)
plant.optimize(target_production=1000.0)

# Display plant summary (like model.summary)
plant.summary()
```

**Output:**
````
# SPROCLIB - Standard Process Control Library

A comprehensive Python library for chemical process control with modular process unit architecture. This library provides essential classes and functions for process modeling, PID control, optimization, and advanced control techniques.

## üèóÔ∏è **Modular Architecture**

SPROCLIB features a new modular structure where each process unit is organized in its own directory under `/unit/`. This makes it easy for contributors to add new equipment models and for users to understand the library structure.

```
unit/
‚îú‚îÄ‚îÄ base/                 # Abstract base classes
‚îú‚îÄ‚îÄ reactor/              # Reactor models (CSTR, PFR, Batch, etc.)
‚îú‚îÄ‚îÄ tank/                 # Tank and storage models
‚îú‚îÄ‚îÄ heat_exchanger/       # Heat transfer equipment
‚îú‚îÄ‚îÄ distillation/         # Separation equipment
‚îú‚îÄ‚îÄ valve/                # Flow control equipment
‚îî‚îÄ‚îÄ utilities/            # Helper classes and tools
```

## Features

### **Core Process Models** (14 Classes)

**Base Classes:**
1. **ProcessModel** - Abstract base class for all process models (`unit/base/`)

**Reactor Models:**
2. **CSTR** - Continuous Stirred Tank Reactor with Arrhenius kinetics (`unit/reactor/cstr/`)
3. **PlugFlowReactor** - Plug flow reactor model with axial dispersion (`unit/reactor/pfr/`)
4. **BatchReactor** - Batch reactor with time-dependent dynamics (`unit/reactor/batch/`)
5. **FixedBedReactor** - Fixed bed catalytic reactor model (`unit/reactor/fixed_bed/`)
6. **SemiBatchReactor** - Semi-batch reactor for feed control (`unit/reactor/semi_batch/`)

**Unit Operation Models:**
7. **Tank** - Gravity-drained tank for level control systems (`unit/tank/single/`)
8. **InteractingTanks** - Multi-tank systems with interaction (`unit/tank/interacting/`)
9. **HeatExchanger** - Shell-and-tube heat exchanger model (`unit/heat_exchanger/`)
10. **DistillationTray** - Single tray distillation model (`unit/distillation/tray/`)
11. **BinaryDistillationColumn** - Multi-tray distillation column (`unit/distillation/column/`)

**Control Equipment:**
12. **ControlValve** - Flow coefficient-based control valve with dead-time (`unit/valve/control/`)
13. **ThreeWayValve** - Three-way mixing/diverting valve model (`unit/valve/three_way/`)

**Utility Classes:**
14. **LinearApproximation** - Linearization tools for nonlinear models (`unit/utilities/`)

### üéÆ **Controllers & Tuning** (5 Classes)

1. **PIDController** - Advanced PID with anti-windup, bumpless transfer, setpoint weighting
2. **TuningRule** - Abstract base for tuning methods
3. **ZieglerNicholsTuning** - Classic Ziegler-Nichols tuning rules
4. **AMIGOTuning** - Advanced Method for Integrating and General Oscillatory processes
5. **RelayTuning** - Relay feedback tuning method

### **Analysis & Optimization** (4 Classes)

1. **TransferFunction** - Transfer function analysis and frequency domain methods
2. **Simulation** - Process simulation with ODE integration
3. **Optimization** - Linear and nonlinear optimization tools
4. **StateTaskNetwork** - Batch process scheduling and planning

### **10 Essential Functions**

1. **step_response** - Calculate step response of systems
2. **bode_plot** - Generate Bode plots for frequency analysis
3. **linearize** - Linearize nonlinear models around operating points
4. **tune_pid** - Automated PID tuning with multiple methods
5. **simulate_process** - Simulate process dynamics with input profiles
6. **optimize_operation** - Optimize process operations
7. **fit_fopdt** - Fit First Order Plus Dead Time models to data
8. **stability_analysis** - Analyze system stability
9. **disturbance_rejection** - Design for disturbance rejection
10. **model_predictive_control** - Basic MPC implementation

## Installation

```bash
# Clone the repository
git clone https://github.com/your-repo/chemical-process-control.git
cd chemical-process-control

# Install dependencies
pip install -r requirements.txt

# Install the library
pip install -e .
```

## Quick Start

### Using the New Modular Structure

```python
# Import individual process units from their specific modules
from paramus.chemistry.process_control.unit.tank.single import Tank
from paramus.chemistry.process_control.unit.reactor.cstr import CSTR
from paramus.chemistry.process_control.unit.valve.control import ControlValve
import numpy as np

# Create a gravity-drained tank model
tank = Tank(area=1.0, Cv=2.0)

# Create a CSTR with reaction kinetics
cstr = CSTR(volume=1.0, k_reaction=0.1, E_activation=50000.0)

# Create a control valve
valve = ControlValve(Cv_max=10.0, time_constant=5.0)

# Design PID controller
model_params = {'K': 1.0, 'tau': 5.0, 'theta': 1.0}
pid_params = tune_pid(model_params, method='ziegler_nichols')
controller = PIDController(**pid_params)

# Simulate closed-loop response
# ... (see examples.py for complete examples)
```

## Examples

### Example 1: Tank Level Control

```python
# Create tank model
tank = Tank(A=1.0, C=2.0, name="LevelTank")

# Linearize around operating point
u_nominal = np.array([2.0])  # Flow rate
linear_approx = LinearApproximation(tank)
A, B = linear_approx.linearize(u_nominal)

# Design PI controller
fopdt_params = {'K': 0.25, 'tau': 1.0, 'theta': 0.1}
pi_params = tune_pid(fopdt_params, method='amigo', controller_type='PI')
controller = PIDController(**pi_params)
```

### Example 2: CSTR Temperature Control

```python
# Create CSTR model
cstr = CSTR(V=100.0, k0=7.2e10, Ea=72750.0)

# Simulate with cooling control
def coolant_profile(t):
    return np.array([100.0, 1.0, 350.0, 300.0 - 5.0*np.sin(0.1*t)])

simulation = Simulation(cstr)
results = simulation.run(
    t_span=(0, 50),
    x0=np.array([0.5, 350.0]),
    u_profile=coolant_profile
)
```

### Example 3: Heat Exchanger Control

```python
# Create heat exchanger model
hx = HeatExchanger(
    U=500.0,           # Heat transfer coefficient [W/m¬≤¬∑K]
    A=10.0,            # Heat transfer area [m¬≤]
    m_hot=2.0,         # Hot fluid flow rate [kg/s]
    m_cold=1.8,        # Cold fluid flow rate [kg/s]
    name="CounterCurrentHX"
)

# Operating conditions
T_hot_in = 363.15    # 90¬∞C
T_cold_in = 293.15   # 20¬∞C
u_nominal = np.array([T_hot_in, T_cold_in])

# Calculate steady-state outlet temperatures
T_outlets = hx.steady_state(u_nominal)
print(f"Hot outlet: {T_outlets[0]-273.15:.1f}¬∞C")
print(f"Cold outlet: {T_outlets[1]-273.15:.1f}¬∞C")

# Calculate heat transfer rate
Q_rate = hx.calculate_heat_transfer_rate(T_hot_in, T_cold_in, T_outlets[0], T_outlets[1])
print(f"Heat transfer rate: {Q_rate/1000:.1f} kW")

# Design temperature controller
linear_approx = LinearApproximation(hx)
A, B = linear_approx.linearize(u_nominal, T_outlets)
step_data = linear_approx.step_response(input_idx=0, step_size=5.0)
fopdt_params = fit_fopdt(step_data['t'], step_data['x'][0, :], step_magnitude=5.0)
pid_params = tune_pid(fopdt_params, method='ziegler_nichols')
controller = PIDController(**pid_params)
```

### Example 4: Distillation Column Control

```python
# Create binary distillation column
column = BinaryDistillationColumn(
    N_trays=10,              # 10 trays total
    feed_tray=5,             # Feed on tray 5
    alpha=2.5,               # Relative volatility
    feed_flow=100.0,         # Feed flow rate [kmol/min]
    feed_composition=0.5,    # 50% light component
    name="BinaryColumn"
)

# Operating conditions
R = 2.0          # Reflux ratio
D = 48.0         # Distillate flow [kmol/min]
B = 52.0         # Bottoms flow [kmol/min]
Q_reb = 500.0    # Reboiler heat duty

u_nominal = np.array([R, Q_reb, D, B])

# Calculate steady-state composition profile
x_steady = column.steady_state(u_nominal)
print(f"Distillate composition: {x_steady[column.N_trays]:.1%}")
print(f"Bottoms composition: {x_steady[column.N_trays+1]:.1%}")

# Calculate separation performance
metrics = column.calculate_separation_metrics(x_steady)
print(f"Separation factor: {metrics['separation_factor']:.1f}")

# Calculate minimum reflux ratio
R_min = column.calculate_minimum_reflux()
print(f"Minimum reflux ratio: {R_min:.2f}")

# Design composition controller
linear_approx = LinearApproximation(column)
A, B = linear_approx.linearize(u_nominal, x_steady)
step_data = linear_approx.step_response(input_idx=0, step_size=0.1)

# Fit FOPDT and design PI controller
fopdt_params = fit_fopdt(step_data['t'], step_data['x'][column.N_trays, :], step_magnitude=0.1)
pi_params = tune_pid(fopdt_params, method='amigo', controller_type='PI')
controller = PIDController(**pi_params)
```

### Example 5: Transfer Function Analysis

```python
# Create transfer function
tf = TransferFunction.first_order_plus_dead_time(K=2.0, tau=5.0, theta=1.0)

# Frequency analysis
bode_data = tf.bode_plot(plot=True)
stability = tf.stability_analysis()

print(f"Gain margin: {stability['gain_margin_db']:.1f} dB")
print(f"Phase margin: {stability['phase_margin_deg']:.1f} degrees")
```

### Example 6: Process Optimization

```python
# Economic optimization
optimizer = Optimization()
result = optimizer.economic_optimization(
    production_rates=np.zeros(3),
    costs=np.array([10, 15, 20]),
    prices=np.array([25, 30, 40]),
    capacity_constraints=np.array([100, 80, 60]),
    demand_constraints=np.array([20, 15, 10])
)
```

### Example 7: Compressor Modeling and Control

```python
# Create gas compressor model
compressor = Compressor(
    eta_isentropic=0.75,         # 75% isentropic efficiency
    P_suction=1e5,               # 1 bar suction pressure [Pa]
    P_discharge=5e5,             # 5 bar discharge pressure [Pa]
    T_suction=288.15,            # 15¬∞C suction temperature [K]
    gamma=1.4,                   # Heat capacity ratio for air
    flow_nominal=10.0,           # 10 mol/s nominal flow
    name="CentrifugalCompressor"
)

# Operating conditions
P_suc = 1.2e5      # 1.2 bar suction pressure
T_suc = 293.15     # 20¬∞C suction temperature
P_dis = 6e5        # 6 bar discharge pressure
flow = 8.0         # 8 mol/s flow rate

u_nominal = np.array([P_suc, T_suc, P_dis, flow])

# Calculate steady-state performance
steady_state = compressor.steady_state(u_nominal)
T_out = steady_state[0]    # Outlet temperature [K]
Power = steady_state[1]    # Power required [W]

print(f"Outlet temperature: {T_out-273.15:.1f} ¬∞C")
print(f"Power required: {Power/1000:.1f} kW")
print(f"Temperature rise: {T_out-T_suc:.1f} K")

# Dynamic simulation
def pressure_step(t):
    if t < 5:
        return u_nominal
    else:
        u_step = u_nominal.copy()
        u_step[2] = P_dis * 1.2  # 20% pressure increase
        return u_step

x0 = np.array([T_out])
results = compressor.simulate(
    t_span=(0, 15),
    x0=x0,
    u_func=pressure_step,
    t_eval=np.linspace(0, 15, 100)
)

print(f"Temperature response to pressure step:")
print(f"Final temperature: {results['x'][0, -1]-273.15:.1f} ¬∞C")
```

### Example 8: Pump System Design and Control

```python
# Create different pump types
centrifugal_pump = CentrifugalPump(
    H0=60.0,                     # 60 m shutoff head
    K=15.0,                      # Head-flow coefficient
    eta=0.78,                    # 78% efficiency
    rho=1000.0,                  # Water density [kg/m¬≥]
    name="CentrifugalPump"
)

positive_pump = PositiveDisplacementPump(
    flow_rate=0.008,             # 8 L/s constant flow
    eta=0.85,                    # 85% efficiency
    rho=1000.0,                  # Water density [kg/m¬≥]
    name="PositiveDisplacementPump"
)

# Compare pump performance
P_inlet = 1e5      # 1 bar inlet pressure
flow_rates = np.linspace(0.005, 0.015, 6)  # 5-15 L/s range

print("Flow [L/s]  Centrifugal P_out [bar]  PD P_out [bar]")
for flow in flow_rates:
    # Centrifugal pump performance
    u_cent = np.array([P_inlet, flow])
    result_cent = centrifugal_pump.steady_state(u_cent)
    P_out_cent = result_cent[0]
    
    # Positive displacement pump (fixed flow)
    u_pd = np.array([P_inlet])
    result_pd = positive_pump.steady_state(u_pd)
    P_out_pd = result_pd[0]
    
    print(f"{flow*1000:8.1f}     {P_out_cent/1e5:16.2f}        {P_out_pd/1e5:.2f}")

# Control system design
linear_approx = LinearApproximation(centrifugal_pump)
u_nominal = np.array([P_inlet, 0.01])  # 10 L/s operating point
x_steady = centrifugal_pump.steady_state(u_nominal)

# Linearize for control design
A, B = linear_approx.linearize(u_nominal, x_steady)

# Step response analysis
step_data = linear_approx.step_response(
    input_idx=1,      # Flow rate input
    step_size=0.002,  # 2 L/s step
    t_final=10.0
)

# Design PI controller
fopdt_params = fit_fopdt(step_data['t'], step_data['x'][0, :], step_magnitude=0.002)
pid_params = tune_pid(fopdt_params, method='ziegler_nichols', controller_type='PI')

controller = PIDController(
    Kp=pid_params['Kp'],
    Ki=pid_params['Ki'],
    output_limits=(0.001, 0.02),  # Flow limits [m¬≥/s]
    name="PumpFlowController"
)

print(f"PI Controller tuned: Kp={pid_params['Kp']:.3f}, Ki={pid_params['Ki']:.3f}")
```

### Example 9: Integrated Compressor-Pump System

```python
# Create system components
compressor = Compressor(
    eta_isentropic=0.78,
    P_suction=1e5,               # 1 bar
    P_discharge=8e5,             # 8 bar
    T_suction=298.15,            # 25¬∞C
    name="SystemCompressor"
)

pump = CentrifugalPump(
    H0=80.0,                     # 80 m shutoff head
    K=25.0,                      # Head-flow coefficient
    eta=0.75,                    # 75% efficiency
    name="SystemPump"
)

# Operating scenarios
scenarios = [
    {"name": "Normal Operation", "comp_flow": 12.0, "pump_flow": 0.012},
    {"name": "High Demand", "comp_flow": 15.0, "pump_flow": 0.015},
    {"name": "Low Demand", "comp_flow": 8.0, "pump_flow": 0.008}
]

print("Scenario           Comp Power [kW]  Pump Power [kW]  Total Power [kW]")
print("-" * 70)

for scenario in scenarios:
    # Compressor performance
    u_comp = np.array([compressor.P_suction, compressor.T_suction, 
                      compressor.P_discharge, scenario["comp_flow"]])
    comp_result = compressor.steady_state(u_comp)
    comp_power = comp_result[1] / 1000  # Convert to kW
    
    # Pump performance
    u_pump = np.array([1e5, scenario["pump_flow"]])
    pump_result = pump.steady_state(u_pump)
    pump_power = pump_result[1] / 1000  # Convert to kW
    
    total_power = comp_power + pump_power
    
    print(f"{scenario['name']:<18} {comp_power:<15.1f} {pump_power:<15.1f} {total_power:.1f}")

# Energy optimization
print(f"\nEnergy optimization strategies:")
print(f"‚Ä¢ Variable speed drives for both compressor and pump")
print(f"‚Ä¢ Pressure control with cascade configuration")
print(f"‚Ä¢ Demand forecasting for proactive control")
print(f"‚Ä¢ Surge protection and cavitation prevention")
```

## Library Structure

```
process_control/
‚îú‚îÄ‚îÄ __init__.py           # Main library interface
‚îú‚îÄ‚îÄ controllers.py        # PID controllers and tuning rules
‚îú‚îÄ‚îÄ models.py            # Process models (CSTR, Tank, etc.)
‚îú‚îÄ‚îÄ analysis.py          # Transfer functions, simulation, optimization
‚îú‚îÄ‚îÄ functions.py         # Utility functions
‚îú‚îÄ‚îÄ examples.py          # Complete usage examples
‚îú‚îÄ‚îÄ requirements.txt     # Dependencies
‚îî‚îÄ‚îÄ README.md           # This file
```

## Core Capabilities

### Process Modeling
- **Tank Models**: Gravity-drained tanks with nonlinear dynamics
- **CSTR Models**: Exothermic reactors with Arrhenius kinetics
- **Heat Exchanger Models**: Counter-current heat exchangers with thermal dynamics
- **Distillation Models**: Binary distillation columns with tray-by-tray modeling
- **Reactor Models**: PFR, batch, fixed bed, fluidized bed, membrane, trickle flow, recycle, and catalyst deactivation reactors
- **Compressor Models**: Gas compressors with isentropic efficiency and dynamic response
- **Pump Models**: Centrifugal and positive displacement pumps with performance curves
- **Interacting Systems**: Multi-tank systems and complex processes
- **Linearization**: Automatic linearization around operating points

### Control Design
- **PID Controllers**: Full-featured implementation with advanced options
- **Tuning Methods**: Ziegler-Nichols, AMIGO, Lambda tuning, Relay tuning
- **Anti-windup**: Prevents integrator windup in saturated conditions
- **Bumpless Transfer**: Smooth transitions between manual and automatic modes

### Analysis Tools
- **Frequency Domain**: Bode plots, stability margins, sensitivity analysis
- **Time Domain**: Step response, impulse response, stability analysis
- **Disturbance Rejection**: Design for load disturbance rejection
- **Performance Metrics**: Settling time, overshoot, steady-state error

### Optimization
- **Linear Programming**: Production planning and resource allocation
- **Nonlinear Optimization**: Operating point optimization
- **Economic Optimization**: Profit maximization with constraints
- **Batch Scheduling**: State-Task Networks for batch processes

### Advanced Control
- **Model Predictive Control**: Basic MPC formulation and implementation
- **State-Space Methods**: Linear algebra-based control design
- **Multivariable Systems**: MIMO system analysis and control

## Educational Use

This library is designed to support learning and teaching of chemical process control concepts:

- **Educational Focus**: Supports academic and industrial process control education
- **Hands-on Learning**: Interactive examples and exercises
- **Visualization**: Built-in plotting for all major analysis tools
- **Progressive Complexity**: From simple tanks to advanced MPC

## Advanced Features

### Robust Control Design
```python
# Design controller with robustness margins
controller_params = tune_pid(
    model_params, 
    method='amigo',  # Known for robustness
    controller_type='PID'
)

# Analyze robustness
stability = stability_analysis(A_matrix)
margins = bode_plot(transfer_function)
```

### Multi-objective Optimization
```python
# Optimize multiple objectives
def multi_objective(x):
    cost = economic_cost(x)
    environmental = environmental_impact(x)
    return cost + 0.5 * environmental  # Weighted sum

result = optimize_operation(multi_objective, x0, constraints, bounds)
```

### Real-time Implementation
```python
# Real-time controller implementation
controller = PIDController(Kp=2.0, Ki=0.5, Kd=0.1)
controller.set_auto_mode()

# In control loop:
# mv = controller.update(t, setpoint, measurement)
```

## Dependencies

- **NumPy**: Numerical computing foundation
- **SciPy**: Scientific computing and optimization
- **Matplotlib**: Plotting and visualization
- **Optional**: Pyomo (algebraic modeling), python-control (advanced control)

## Contributing to the Modular Architecture

We welcome contributions! The new modular structure makes it easy to add new process units.

### Adding a New Process Unit

1. **Choose the appropriate category** under `/unit/` (reactor, tank, heat_exchanger, etc.)
2. **Create a new subdirectory** for your unit (e.g., `/unit/reactor/membrane/`)
3. **Follow the established structure**:
   ```
   unit/reactor/membrane/
   ‚îú‚îÄ‚îÄ __init__.py      # Your process unit class
   ‚îú‚îÄ‚îÄ README.md        # Documentation and usage
   ‚îú‚îÄ‚îÄ example.py       # Demonstration script
   ‚îî‚îÄ‚îÄ tests.py         # Unit tests
   ```

4. **Inherit from ProcessModel**:
   ```python
   from paramus.chemistry.process_control.unit.base import ProcessModel
   
   class MembraneReactor(ProcessModel):
       def __init__(self, ...):
           super().__init__("MembraneReactor")
           # Your initialization code
           
       def dynamics(self, t, x, u):
           # Your process dynamics
           return dx_dt
   ```

5. **Update the parent `__init__.py`** to include your new unit
6. **Add comprehensive documentation** and examples

### Areas for Enhancement

1. **Additional Models**: 
   - Pumps and compressors
   - Advanced reactor types (membrane, microreactor)
   - Separation equipment (extractors, absorbers)
   - Utility equipment (cooling towers, boilers)

2. **Advanced Control**: 
   - Robust control, adaptive control, nonlinear MPC
   - Cascade control, feedforward control, override control

3. **Industrial Features**: 
   - Process safety systems
   - Alarm and interlock systems
   - Data reconciliation

4. **Integration Tools**: 
   - Parameter estimation utilities
   - System identification methods
   - Process optimization frameworks

5. **Visualization**: 
   - Interactive plots, 3D visualization, animations
   - Process flow diagram generation

### Contributor Guidelines

- Follow the existing code style and documentation patterns
- Include comprehensive docstrings and type hints
- Add example usage in `example.py`
- Write unit tests in `tests.py`
- Update relevant README.md files

## License

This library is provided for educational and industrial use under the MIT License. It is designed to support learning and application of chemical process control concepts in academic and industrial settings.

## License

SPROCLIB is released under the MIT License. See LICENSE file for details.

## References

- Kantor, J.C. "Chemical Process Control" https://jckantor.github.io/CBE30338/
- √Östr√∂m, K.J. and H√§gglund, T. "Advanced PID Control"
- Seborg, D.E., Edgar, T.F., Mellichamp, D.A. "Process Dynamics and Control"

## Support

For questions, suggestions, or contributions, please contact:
- **Thorsten Gressling**: gressling@paramus.ai

For questions, issues, or contributions:
- Create an issue on GitHub
- Review the examples.py file for comprehensive usage examples
- Check the documentation for theoretical background and implementation details

---

**SPROCLIB - Standard Process Control Library** - Making process control accessible through Python!

Created by: **Thorsten Gressling** (gressling@paramus.ai)  
License: **MIT License**
````
